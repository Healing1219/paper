\documentclass[sigconf,review, anonymous]{acmart}
\acmConference[ESEC/FSE 2020]{The 28th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering}{8 - 13 November, 2020}{Sacramento, California, United States}
%
\usepackage{booktabs,algorithm,algorithmic,multirow,amsmath,xcolor,bm,makecell,balance} % For formal tables

\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}
\newcommand\leaveout[1]{}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

\acmYear{2020}
\copyrightyear{2020}

\acmPrice{15.00}


\begin{document}
\title{TAP: a Tool for Analyzing Termination and Assertions for Probabilistic Programs}
%\titlenote{Produces the permission block, and
%  copyright information}
%\subtitle{Extended Abstract}
%\subtitlenote{The full version of the author's guide is available as
%  \texttt{acmart.pdf} document}


\author{Ben Trovato}
%\authornote{Dr.~Trovato insisted his name be first.}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin} 
  \state{Ohio} 
  \postcode{43017-6221}
}
\email{trovato@corporation.com}

\author{G.K.M. Tobin}
%\authornote{The secretary disavows any knowledge of this author's actions.}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin} 
  \state{Ohio} 
  \postcode{43017-6221}
}
\email{webmaster@marysville-ohio.com}

\author{Lars Th{\o}rv{\"a}ld}
%\authornote{This author is the one who did all the really hard work.}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla} 
  \country{Iceland}}
\email{larst@affiliation.org}

% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
  Probabilistic programs combine probabilistic reasoning models with Turing complete programming languages, unify formal descriptions of calculation and uncertain knowledge, and can effectively deal with complex relational models and uncertain problems. This paper presents TAP, a  tool  for analyzing termination and assertions for probabilistic programs. On one hand, it can help to analyze the termination property of  probabilistic programs both qualitatively and quantitatively. It can check whether a probabilistic program terminates with probability $1$,  estimate the expected termination time, and calculate the number of steps after which the termination probability of the given probabilistic program decreases exponentially.  On the other hand, it can estimate the correct probability interval for a given assertion to hold, which helps to analyze the influence of uncertainty of variables on the results of probabilistic programs.
  %They can be effectively checked in polynomial time. TAP supports  more than ten kinds of built-in probability distributions. 
The effectiveness of TAP is demonstrated through various probabilsitic programs.
\end{abstract}

\leaveout{
%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}
}

\ccsdesc[500]{Software and its engineering~Software notatins and tools}

% We no longer use \terms command
%\terms{Theory}

\keywords{Probabilistic Programming, Program Verification, Probability Intervals, Termination}


\maketitle


\section{Introduction}
There are a large number of uncertainty problems in the real world, which requires us to use prerequisite knowledge and deductive reasoning to predict the results, that is to say, to make decisions on nondeterministic problems through probability reasoning. Therefore, probabilistic programs are put forward for that purpose. Probabilistic programs are a kind of logic programs with probabilistic facts. They make probabilistic reasoning models easier to build and can estimate the possibilities of for  certain events to occur.
Probabilistic programs have a wide range of applications in various fields such as business, military, scientific research and daily life. Probability is becoming more and more important in actual calculations, such as risk analysis, medical decision-making, differential privacy mechanisms~\cite{Dwork2014Differential}, etc. The analysis of probabilistic programs has also received widespread attention in academia and industry. %Therefore, we need to learn the impact of probabilitisic variables on the program results, analyze and verify the properties of probabilistic grams, so as to ensure that the final results of the program have good reliability and stability.

In the current work we present presents TAP, a verification tool  for analyzing Termination and Assertions for Probabilistic programs. It can automatically analyze whether a probabilistic program conforms to a specification.
%(As shown in Figure \ref{syntaxy}).
It mainly includes two parts: one is to analyze the termination property of a given probabilistic program qualitatively and quantitatively; the other is to estimate the correct probability interval for a given assertion to hold.
More specifically, TAP provides the following functionalities:
\begin{enumerate}
\item Defining and parsing probabilistic programs. More than ten kinds of probability distributions are built in, which is convenient to be called to build probabilistic models.
  \item Reducing the termination analysis of a given program to a linear programming problem. We also consider the concentration results under the premise that the program is terminating.
	\item Reducing the estimation of a given assertion to a polyhedron solving problem. Note that we support probabilistic programs with infinitely many states.
	
\end{enumerate}
The tool and the experimental data given in this paper are all available in the repository \url{https://github.com/}.

\section{Probabilistic Programs}
\begin{figure}[ht]
	\centering
	\begin{tabular}{rcl}
		\hline
		% after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
		program & $:=$ & typeSpecifier main\{$stmt^*$\} \\
		stmt & $:=$ & assign | condStmt | while \\
		assign & $:=$ & intAssign | realAssign \\
		condStmt & $:=$ & ifStmt | ifElseStmt\\
		while & $:=$ & while (test) $stmt^*$\\
		intAssign & $:=$ &  intVar = intConst | intVar $\sim$ intRandom\\
		realAssign & $:=$ & realVar = realConst | realVar $\sim$ realRandom\\
		intRandom & $:=$ & uniformInt(intConst, intConst)\\
		&  & | Bernoulli(intConst, intConst)\\
		&  & $\cdots$ \\
		realRandom & $:=$ & uniformReal(realConst, realConst)\\
		&  & | Gaussian(realConst, realConst)\\
		&  & $\cdots$ \\
		intExpr & $:=$ & intConst | intRandom | intExpr $\pm$ intExpr\\
		& & intConst* intExpr | intExpr / intConst\\
		realExpr & $:=$ & realConst | realRandom | realExpr $\pm$ realExpr\\
		& & realConst* realExpr | realExpr / realConst\\
		boolExpr& $:=$ & true | false | boolExpr $\wedge$ boolExpr \\
		& & intExpr relop intExpr | realExpr relop realExpr\\
		relop & $:=$ & <  |  > | $\geq$ | $\leq$ | ==\\
		\hline
	\end{tabular}
	\caption{Syntax specification of a probabilistic language}	\label{syntax}
\end{figure}
In order to analyze and verify probabilistic programs, we first need a probabilistic language sufficiently expressive and easy to understand. We follow \cite{Minka2012Compiler} to define a probabilistic language, whose syntax specification is shown in Figure~\ref{syntax}. The statements in the probabilistic language are similar to those in classic imperative languages, mainly composed of three types of statements: assignment, condition-branch (if-else) and loop statements (while). The main difference is that we now have a collection of random value generators as listed in Table~\ref{distribution}, which can be used to simulate different probability distributions. Variables are classified into two types: program variables and sampling variables. Program variables include integer, real, and boolean variables. Boolean variables are mainly used for condition  and loop statements. Sampling variables are assigned with dynamically generated values when the program is running, which is subject to a continuous  or discrete probability distribution.

\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\begin{table}[htb]
	\caption{Specification of the inbuilt random value generators}
	\label{distribution}
	\begin{tabular}{lll}  
		\toprule   
		Name & Parameter & \makebox[4cm][c]{Density Function} \\  
		\midrule   
		R($\mathbb{X},\mathbb{P}$) & $\sum\limits_{n=1}^N p_n$=1 & $P(X=x_k)=p_k$\\  
		Binomial(n,p) & \tabincell{c}{0<p<1\\n$\geq$1} &$\tbinom{k}{n}p^k(1-p)^{n-k}, k=1,2,\dots$ \\  
		Poisson($\lambda$) & $\lambda$>0 &$\frac{\lambda^ke^{-\lambda}}{k!}$ \\   
		UnifInt(a,b) & a$\leq$b & 
		$\left\{
		\begin{array}{lr}
			\frac{1}{b-a} &, b>a \\
			1 & ,a=b\\
		\end{array}
		\right.$ \\
		UnifReal(a,b) & a<b & $\frac{1}{b-a}$ \\  
		Exponential($\theta$) & $\theta$>0 & $\frac{1}{\theta}e^{\frac{x}{\theta}}$ \\    
		Normal($\mu$,$\sigma^2$) &$\sigma$>0 &$\frac{1}{\sqrt{2\pi}\sigma}e^{-(x-\mu)^2/(2\sigma^2)}$ \\
		Gamma($\alpha$,$\beta$) & $\alpha, \beta$>0 & 
		$\frac{1}{\beta^\alpha\Gamma(\alpha)}x^{\alpha-1}e^{\frac{-x}{\beta}} , x>0 $  \\  
		Beta($\alpha$,$\beta$) & $\alpha, \beta$>0 & $\frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1}$,0<x<1\\    
		Laplace(x|$\mu,\lambda$) & $\lambda>0$ &$\frac{1}{2\lambda}e^{\frac{|x-\mu|}{\lambda}}$ \\
		Geometric(p) & 0<p<1 & $(1-p)^{k-1}p, k=1,2,\dots$ \\     
		T(n) &n$\geq$1 &$\frac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\frac{x^2}{n})^{-(n+1)/2}$ \\
		\bottomrule  
	\end{tabular}
\end{table}

We use control flow graphs (CFGs) to express the semantics of probabilistic programs~\cite{Kozen1981Semantics}. Formally, a CFG is a tuple in the form $(L,X,R,\mapsto,\bot)$, where:

\begin{itemize}
\item $L$ is a finite set of labels $L=\{\ell_0,\ell_1,\dots,\ell_n\}$ used to represent control locations. Each statement in a program has a unique label. For example, $\ell_0$ usually indicates the starting location.
  %, $\ell$$_n$ indicates the last location.

\item $X=\{x_0,\dots,x_n\}$ is a set of program variables and $R=\{r_1,\dots,r_m\}$ is a set of sampling variables.

\item $\mapsto$ is a transition relation. Its element is in the form $(\ell,\alpha,\ell')$, representing one step of transition from control location $\ell$ to $\ell'$, by performing action $\alpha$.

\item $\bot$ is a sign of the exit of the program.
\end{itemize}

\section{Termination Analysis}
Termination analysis~\cite{Codish1999Semantic} is an important part of program verification. Ensuring termination is a necessary condition for many properties of programs such as total correctness. A powerful technique for proving probabilistic termination is to synthesize ranking supermartingales~\cite{Chakarov2013Martingales,Hermanns2013Probabilistic,cha2015algorithmic,kris2016termination}. TAP implements Algorithm~\ref{TA} to analyze probabilistic termination qualitatively and quantitatively. 
\begin{algorithm}[htb]  
	\caption{Termination Analysis.}  
	\label{TA}  
	\begin{algorithmic}[1]  
		\REQUIRE 
		Program P; 
		\ENSURE  
		Judge whether the program is terminating, isT;\\
		The probability to terminate afer N steps decreases exponentially, N;
		\STATE Set quadratic template $g(\ell,\boldsymbol{x})$. Each location has the common template with unique coefficient. If $\ell_{\bot}$, the template g=K.
		\STATE Traverse the programs parse tree and collect the invariant I[] for each location.
		\STATE Calculate the pre-expectation for each location.\\
		\quad \quad case "assignment statement" :\\
		\quad \quad \quad \quad $pre(\ell,\boldsymbol{x})= \mathbb{E}(g(\ell',f(\boldsymbol{x},\boldsymbol{r})),\boldsymbol{x})$.\\
		\quad \quad case "condition(if-else) or loop(while) statement" :\\
		\quad \quad \quad \quad $pre(\ell,\boldsymbol{x})=g(\ell',\boldsymbol{x})$.\\
		\quad \quad case "terminal statement" :\\
		\quad \quad \quad \quad $pre(\ell,\boldsymbol{x})=g(\ell,\boldsymbol{x}).$
		\STATE By the concept of half-space, $H=g(\ell,\boldsymbol{x})-pre(\ell,\boldsymbol{x})-\epsilon$
		\STATE By Handelman's Theorem, $H'=\sum\limits_{i=1}^{d} a_i\cdot I_i$, where $\mu=\{\prod\limits_{i=1}^{2}\nu\}$ and $a_i$ is a non-negative real number.
		\STATE Pattern extraction. The coefficient of $H$ corresponds to that of $H'$, which is converted into a linear programming problem. If solvable, the program P can be terminating, otherwise return.
		\STATE Calculate the difference-bounded $[a,b]$ with $(a\leq g(\ell',\boldsymbol{x})-g(\ell,f(\boldsymbol{x},\boldsymbol{r}))\leq b)$
		\STATE Obtain N, according to $\mathbb{P}(\bm{T_p} > N) \leq e^{-\frac{2(\epsilon(N-1)-g(\ell_0,x_0))^2}{(N-1)(b-a)^2}}$
	\end{algorithmic}  
\end{algorithm}  


\paragraph{Qualitative analysis} It mainly analyzes whether the probabilistic programs will terminate with probability $1$ (almost sure termination)~\cite{Hurd2002A}. The specific idea is to calculate the supermartingale of each location and the value of location $\ell$' does not exceed that of location $\ell$. Refer to Algorithm \ref{TA} steps 1 to 6. Supermartingales are represented by the template $g$ with a natural number as its maximal degree. For the sake of simplicity, our tool takes $2$, that is, the template $g$ is a quadratic equation. We calculate the pre-expectation for each location according to the formulas of step $3$, where $\ell$' is the next location of $\ell$ and $f$ is the transition relation from location $\ell$ to $\ell$'. Since the pre-expectations belong to a convex set. The definition of half-space $\{x|\textbf{a}^T\textbf{x}\leq b\}$ can be transformed into $\{x|(\textbf{c}^\ell)^T\textbf{x} \leq d^\ell-\epsilon\}$ and $c^\ell$ (resp. $d^\ell$ is a vector (resp. scalar) linear expression related to $pre(\ell,\boldsymbol{x})$. we will apply it to the pre-expectation, it is equivalent to $pre(\ell,\boldsymbol{x}) \leq g(\ell,\boldsymbol{x})-\epsilon$, and $\epsilon$ takes 1. Finally, according to Handelman's theorem, we can transform this problem into a linear programming problem.


\paragraph{Quantitative analysis} We aim to calculate the boundary $N$, so that the probabilistic program concentrates on termination before $N$ steps. That is, the probability of termination after $N$ steps shows an exponential decrement. We focus on the approximation of the expected termination time, cf. steps 7 to 8 in Algorithm \ref{TA}. According to the previous steps, we can find the coefficients of the polynomial template. If we know the initial values of variables, we can see that the value at the first location is $g(\ell, x_0)$, the value is $K$ at the terminated location $\ell_\bot$ and the difference between two consecutive locations is $\epsilon$. For our tool TAP, the value of $K$ is set to be $-1$ and the value of $\epsilon$ is $1$. Therefore, when program $P$ is almost sure terminating, we can get the upper bound on termination time for the given initial condition is: $ET(P) \leq UB(P) = \frac{g(\ell, x_0)-K}{\epsilon}$.  Exponential sum is one of the most commonly used specific function families in nonlinear approximation theory. Our main idea is based on martingale inequality of Azuma's Inequality, Hoeffding's Inequality and Bernstein's Inequality. In probability theory, the Azuma's inequality gives a concentration result for the values of martingales that have bounded differences. Hoeffding's Inequality~\cite{Hoeffding1963} is a special case of Azuma's Inequality. It proposes an upper bound on the probability that the sum of random variables deviates from its expected value. Bernstein's Inequality is a generalization of Hoeffding. It can handle not only independent variables but also weak independent variables. By \cite{cha2015algorithmic}, we know that when $\epsilon(N-1) > g(\ell_0,\boldsymbol{x_0})$, the inequality $\mathbb{P}(\bm{T_p} > N)\leq e^{-\frac{2((N-1)-g(\ell_0,x_0))^2}{(N-1)(b-a)^2}}$ holds. Given the exponent, we can obtain the result of $N$.


\section{Estimating the probabilities of assertions}
The goal of this section is to estimate the probability that a given assertion is correct at the exit of the program. There are two main steps.


The first step is to generate a sufficient and appropriate path set $S$ with high confidence coverage. The finite set $S=\{s_1,\dots,s_i,\dots,s_n\}$ contains distinct paths that are terminating, that is, we have the transition sequences $s_i: \ell_0 \to \dots \to \ell_k \to \dots \to \ell_{\bot}$. The control flow of loop statements on program variables and sampling variables may lead to infinitely many states. Therefore, we adopt the method of simulating symbolic executions. Execution paths can be represented using a tree. Through a symbolic execution~\cite{Geldenhuys2012symbolic}, we traverse the program execution tree and collect the semantic states, so that each path of the program execution is based on the original probability distribution. In this way, our method is able to handle the problem that program $P$ contains program variables and sampling variables with a wide range of distributions or even infinitely many states. Then we need to improve the coverage $c$ of path set $S$ to all paths in a finite amount of time. Estimating the probability of a given assertion $\varphi$ on path set $S$ can be considered approximately as on the whole program. Our implementation is based on \cite{Sankaranarayanan2013Static} where it is shown that the coverage $c$ can be considered to be at least $95\%$ with $99\%$ confidence, when no new path is generated in $90$ consecutive iterations.


The second step is to estimate the probability of a given assertion $\varphi$. For the path set $S$ collected above, we can analyze each path in turn, then estimate the path probability and eventually the assertion probability. Since the calculation of the accurate probabilities is closely related to the volume of $n$-dimensional convex polyhedron, when the dimension increases, the calculation becomes very difficult and the time complexity is high~\cite{Arora1998Proof}. Usually, the computation may fail due to the calculation or insufficient memory. On the premise of weighing the efficiency and accuracy of calculation, we focus on calculating the probability interval of a given assertion rather than the estimated value.

\begin{algorithm}
	\caption{mcBoundProbability}
	\label{mcBoundProbability}
	\begin{algorithmic}[1]
		\REQUIRE Polytop p=(vars, constraints), maxDepth
		\ENSURE Probability interval $[p_1, p_2]$
		\IF{$isABox() || maxDepth<=0$}
			\STATE $[p1,p2]+=computeBoundingProbability()$;
		\ENDIF  \\
		$//$ If at least two (or more) non trivial clusters remain, then perform the
		decomposition.  
		\IF{$isDecomposable(p)$}
			\STATE dim = $selectBranchDimension()$;
			\STATE branches= $branchAndBound(dim, nBranch)$;
			\FOR{$b$ in branches}
			\STATE $mcBoundProbability(b, maxDepth-1)$;
			\ENDFOR
		\ENDIF
	\end{algorithmic}
\end{algorithm}

\paragraph{Path probability} Each path has a series of variables and constraints. We need to estimate the probability of satisfying all constraints given the probability distributions on variables. Each variable can be regarded as a dimension of convex polyhedron. The calculation of path probability can be reduced to a polyhedron solving problem~\cite{Visser2012Green}. However, the solution of a convex polyhedron by linear programming is too rough. Therefore, we first decompose the convex polyhedron into several non-intersecting convex bodies~\cite{Bingsheng2020} and then add up the calculation results. As described in Algorithm~\ref{mcBoundProbability}, the function $isDecomposable()$  is used to determine whether it can be decomposed. If true, it will be decomposed along the selected dimension. When the boundary box is found, the upper and lower bounds will be calculated by the function $computeBoundingProbability()$. Based on the idea of importance sampling, the function $selectBranchDimension()$ selects a dimension which is unbounded or half bound or else it selects the maximum width dimension. The function $branchAndBound()$ performs the decomposition according to the selected dimension. Here, $nBranch$ is the number of segmentation, with the default value $2$. In addition, to avoid infinite decomposition, we set $maxDepth$ as the maximum recurrence depth, with the default value $12$ in TAP. Each path is calculated by the Algorithm \ref{mcBoundProbability}. Since there is no intersection of each path, the path probability is equal to the sum of each paths' probability. Let us assume that the assertion probability is $[p_1,p_2]$. It indicates that the maximum $1-p_1$ path has not been explored. This will be used to calculate the upper bound of the assertion probability.

\begin{table*}[htb]
	\caption{Experimental results: termination analysis}  
	\label{TerminationResult} 
	\begin{center}  
		\begin{tabular}{|l|l|l|l|l|}  
			\hline  	
			Example & $x_0$ & g($\ell_0,x_0$) & UB(P) & N\\ \hline  	
			Simple & $x=100$  & $6x+2$ & 603 & 2670 \\ \hline  		
			NestedLoop & $x=1$ & $1040x+2290$ & 1251 & 382807 \\  \hline  
			Award & bonus=0 & -4.0$\cdot$bonus+442& 443 &10658 \\  \hline  
			RandomWalk & $position=0$ & -20$\cdot$position+122 & 123 & 11937 \\  \hline  
			Gambler& $money=3$ & 400$\cdot$money+402& 1603 & 3641131 \\ \hline  		 
			Gambler2 & $money=10$ & 45.454545$\cdot$money+456.545455 & 913 & 3134301 \\  \hline  
			Bitcoin mining & $coin=10$ & 5.317601$\cdot$coin+2 & 57 & 1.532647E8 \\  \hline 
			Infection & $x=1000$, $p_1$=0.25, $p_2$=0.1, $q=0.3$ & $21.107713+0.038215x+6.6E-5x^2$& 59 & 215 \\  \hline  
		\end{tabular}  
	\end{center}  
\end{table*}

\paragraph{Assertion probability} The method of computing an assertion probability is similar to that of computing a path probability. The only difference is the need to add assertion $\varphi$ to the conditional constraints. Let us assume that the assertion probability is $[q_1,q_2]$. Since the path set $S$ may not cover all the paths in the program, we need to consider the probability of unexplored paths and add the probability beyond the path set $S$ to the upper bound of the assertion probability. Then the probability interval of the given assertion is $[q_1,q_2+(1-p_1)]$.

\section{Experimental Results}
In this section, we present some experimental results of analyzing probabilistic programs using TAP. More details can be found at GitHub.


We have written some simple but classical probabilistic programs with while' loops. In Table~\ref{TerminationResult}, we display the experimental results about termination analysis, where $x_0$ means the initial value of each variable, $g(\ell_0,x_0)$ is the polynomial ranking supermartingale about the starting location, $UB(P)$ is the upper bound of expected termination time and $N$ is the bound that the probability of termination after $N$ steps shows an exponential decrement (we set the exponent to  $1.5 \cdot 10^{-5}$).

\begin{table}[htb]
	\caption{Experimental results: estimating the probability interval of assertions}
	\label{AssertionsResults} 
	\begin{tabular}{c |c |c |c }
		\hline  
		Ex. & Assertion &  $c$ & Bounds \\ \hline
		\multirow{2}{*}{carton}
		& count$\geq$5 & 0.9485 & [0.948540, 1] \\ \cline{2-4}
		& count$\geq$10 & 0.9539, & [0.000639, 0.046711] \\ \cline{2-4}
		& count$\leq$7 & 0.9549 & [0.918762, 0.963832] \\ \cline{2-4}
		& totalWeight$\geq$5.5 & 0.9386 & [0.382145, 0.453010] \\ \cline{2-4}
		& totalWeight$\geq$6 & 0.9428 & [0.246186, 0.342997]  \\ \hline
		\multirow{2}{*}{herman}
		& count$\geq$1 & 0.9561 & [0.581128, 0.625000] \\ \cline{2-4}
		& count$\geq$20 & 0.9701 & [0.000000, 0.029876]  \\ \hline
		\multirow{3}{*}{\makecell[c]{framin\\gham}}
		& points$\geq$10 & 0.9636 & [0.137343, 0.173695] \\ \cline{2-4}
		& pointsErr-points$\geq$5 & 0.9365 & [0.778149, 0.849318]  \\ \cline{2-4}
		& points-pointsErr$\geq$5 & 0.9326 & [0.177619, 0.246763]  \\ \hline
		\multirow{5}{*}{\makecell[c]{sum-\\three}}
		& $x+y>z+10$ & 0.9886 & [0.447672, 0.470723] \\ \cline{2-4}
		& $x+y+z>8$ & 0.9886 & [0.454482, 0.475890] \\ \cline{2-4}
		& $x+y+z>100$ & 0.9886 & [0.012422, 0.025870]  \\ \cline{2-4}
		& $x>5 \ \&\& \ y>0$ & 0.9886 & [0.150535, 0.163590]  \\ \cline{2-4}
		&  \makecell[c]{$x>0 \ \&\&\ y>0$ \\ $\&\& \ z>0$} & 0.9886 & [0.125582, 0.137293] \\ \hline
		\multirow{1}{*}{ckd-epi}
		& $f -f_1\geq0.1$ & 0.9252 & [0.351632, 0.426397] \\ \cline{2-4}
		& $f_1 -f\geq0.1$ & 0.9261 & [0.387275, 0.461157]  \\ \hline
	\end{tabular}  
\end{table}

Table~\ref{AssertionsResults} shows the experimental results about estimating the probability interval of assertions. In the table, an assertion is a boolean expression that can contain addition and subtraction operations and  also supports the use of the logical operator conjunction; $c$ is the lower bound of path coverage; the column headed by Bounds gives the upper and lower bounds of the given assertion. %Due to layout restrictions, some values are not presented in the table, such as the total number of execution paths and unique paths.

\include{relatedworks}

\section{Conclusions and Future Work}
Uncertainty exists in many software systems, including data analysis, stochastic algorithms and Monte Carlo simulation. We have designed TAP  to provide convenience and support for analyzing probabilistic programs.
TAP is helpful to perform qualitative and quantitative analysis on the termination of probabilistic programs. It can also collect path sets with high confidence coverage and compute  probability interval for assertions to hold in probabilistic programs.


However, we have only solved some aspects of the complex problem of probabilistic program analysis and verification. There are still many ways to improve the tool.
\begin{enumerate}
	\item Currently, TAP only deals with linear programs. That is, it cannot handle variable multiplication, division and exponents, etc., regardless of the termination analysis or the estimation of assertion probability interval.
	\item Non-deterministic probabilistic programs  are also not supported. TAP requires the the behavior of the input program to be fully probabilistic, and there is no non-deterministic transitions. 
	\item In the future, we hope to find a better way to compute more accurate probability interval under the premise of ensuring high efficiency. 
\end{enumerate}




%\appendix
%Appendix A
% \section{Headings in Appendices}

% \subsection{Introduction}
% \subsection{The Body of the Paper}
% \subsubsection{Type Changes and  Special Characters}
% \subsubsection{Math Equations}
% \paragraph{Inline (In-text) Equations}
% \paragraph{Display Equations}
% \subsubsection{Citations}
% \subsubsection{Tables}
% \subsubsection{Figures}
% \subsubsection{Theorem-like Constructs}
% \subsubsection*{A Caveat for the \TeX\ Expert}
% \subsection{Conclusions}%

% This next section command marks the start of
% Appendix B, and does not continue the present hierarchy

%\begin{acks}


%\end{acks}


\newpage
\balance
\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc} 

\end{document}
